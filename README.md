# 동시성 제어 방식에 대한 분석 및 보고서

## 동시성 문제란?
동시성이란 여러 작업을 동시에 처리할 수 있는 능력을 말합니다.   
자바에서는 스레드를 사용하여 멀티 스레딩 환경을 구현합니다.  
여러 스레드가 하나의 어플리케이션 안에서 병렬로 실행되면서 같은 자원에 동시에 접근할 경우 경쟁 조건(Race Condition) 문제가 발생할 수 있고, 
둘 이상의 스레드가 임계 구역(Critical Section: 실행 순서에 따라 결과가 달라질 수 있는 코드 영역)을 동시에 실행할 때 동시성 문제가 발생할 수 있습니다.

---
## 문제점
동시성 문제가 발생하게 되면 시스템 데이터 불일치, 교착 상태, 데이터 손상 등 여러 문제가 생길 수 있습니다.

### 1. 데이터 불일치
- 동시에 여러 스레드가 같은 데이터를 수정할 때 발생.
- 실행 순서에 따라 예상하지 못한 값이 저장됨.

### 2.교착 상태
- 여러 스레드가 서로가 가진 자원을 기다리며 무한 대기.
- 시스템이 응답하지 않고 멈춤.

### 3. 데이터 손상
- 여러 개의 스레드가 동시에 같은 메모리 영역을 수정할 때 발생.
- 값이 덮어씌워지거나 잘못된 값이 저장됨.

---

## 동시성 제어 방식

### 1. synchronized

- 공유 자원 접근을 한번에 한 스레드만 가능하도록 제한.
#### 장점

- Java 내장 키워드라 별도로 객체가 필요 없음.
- 구현이 간단함.

#### 단점

- 락을 기다리는 스레드의 순서를 보장하지 않음.(FIFO x)
- 재시도, 타임아웃, 조건대기 등 상세한 제어 불가능.
- 성능이 중요한 경우에는 과도한 락 경쟁 발생.


### 2. Atomic

- 락 없이 원자적 연산을 제공하는 클래스(`AtomicInteger`, `AtomicBoolean`, `AtomicReference` ...)를 이용 

#### 장점

- 락을 사용할 때 보다 성능이 좋음.
- `compareAndSet()`, `getAndAdd()` 등 다양한 연산 지원

#### 단점

- 복잡한 로직에는 부적합.
- 여러 변수 간 일관성 보장 못함.
- 실수로 여러 연산을 조합할 경우 경쟁 조건 발생 가능

### 3. CompletableFuture

- 비동기 작업을 처리하기 위한 클래스 (`java.util.concurrent`)
- 스레드를 블로킹 하지 않고 작업 완료 후 콜백 처리 가능

#### 장점

- 비동기, 논블로킹 프로그래밍 가능
- 코드 흐름을 함수형 스타일로 작성 가능, 코드가 간결해짐

#### 단점

- 디버깅과 예외처리가 복잡할 수 있음.
- 멀티 스레드 환경에서 상태 공유 시 주의 필요

### 4. ConcurrentHashMap

- 동시 접근을 지원하는 자료구조
- 내부적으로 세그먼트 단위로 락을 걸어 병렬 처리.

#### 장점

- 높은 동시성을 제공하며, 읽기 작업이 많은 경우 효율적이고, thread-safe 함.

#### 단점

- 전체 순회나 복잡한 조작은 비효율적일 수 있음.


### 5. ReentrantLock

- Java의 고급 락 객체 (`java.util.concurrent.locks`) 
- synchronized보다 세밀한 락 제어 가능

#### 장점

- 공정성 설정 가능 (FIFO)
- 스레드가 필요할 때 잠금을 해제할 수 있어 유연한 제어가 가능

#### 단점

- 락 잠금 해제를 하지 않으면 교착 상태가 발생할 수 있음.


---
## 문제 해결 방식

요구사항에서는 “동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.” 라고 작성되어 있습니다.

1. 한명의 사용자에 의해서 여러 요청이 들어오는 경우
2. 여러명의 사용자에 의해서 여러 요청이 들어오는 경우

2번의 경우 만약 A, B, C 각각 다른 사용자가 요청을 보낼 경우 각 유저에 해당하는 row를 처리하기 때문에   
요구사항에서 이야기하는 동시성 문제가 발생할 수 있는 상황은 한명의 사용자가 여러 건의 충전, 이용 요청을 보내는 상황이 적합하고 판단했습니다.

여러 사용자의 요청에 대해서는 병렬 처리를 하고, 한 사용자의 여러 요청에 대해서는 순차적으로 처리하기 위해 
전역에 하나의 락만 사용하는 `synchronized` 대신 더 유연한 제어를 할 수 있도록
`ReentrantLock` 과 `ConcurrentHashMap`을 사용하여 성능상의 이점과 최소한의 임계 영역만 설정하여 문제를 해결했습니다.

